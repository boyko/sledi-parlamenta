## Какво прави
Скриптът извлича информаця за дейността на всеки народен представител от стенограмите налични в XLS формат на http://www.parliament.bg/bg/plenaryst .

За момента информацията е сведена до:

 - присъствие
 - избор за всяко гласуване

## Очакван резултат
Дейността на 1 народен представеител за всеки 1 работен ден е представена като `JSON` документ под формата:

```json
{
    "name": "Иван Иванов",
    "date": "21/05/2013",
    "votes": [
        {
            "topic": "Увеличение на бюджета",
            "val": "yes",
            "time": "21-05-2013 11:54"
        },
        {
            "topic": "Решение за избор на председател",
            "val": "yes",
            "time": "21-05-2013 09:21"
        }
    ],
    "registration": {
        "time": "21-05-2013 11:30",
        "val": "present"
    }
}
```

## Изисквания
 - `php` 5.3+
 - `nodejs` (тествано с `0.10.13`)

и техните *"package manager"*-и:

 - `composer`
 - `npm`

За инсталацията на точна, лесно сменима версия на `nodejs` е удобно да се ползва [nvm](https://github.com/creationix/nvm)

## Инсталация

```bash
bash ./build.sh
```

## Употреба
```bash
node run.js --url=http://www.parliament.bg/bg/plenaryst
```

което ще изведе поредица от `json` документи, с по един документ на 1 ред, тоест:

```json
{"name":"Иван Иванов","date":"21/05/2013","votes":[{"topic":"Budget increase","val":"yes","time":"21-05-2013 11:54"}, /*...*/],"registration":{/*...*/}}
 ```

Ето и _"help"_-а на скрипта за повече яснота:

```
Crawls parliament.bg and extracts MPs' voting infromation.
Usage: node ./run.js

Options:
  -u, --url   Url to act as a start page for the crawl          [required]
  -d, --date  Date as unix time. Start date for the crawl       [default: null]
  -t, --temp  Temporary directory to store the raw transcripts  [default: "/var/tmp"]
```
### Детайли
#### URL
URL-то фактически определя кое (42ро, 41во...) народно събание ще се _"crawl"_-ва.

#### Date
Може да се подаде и стартова дата, преди която стенограмите нямат да бъдат обработвани. Дататата трябва да е _"unix timestamp"_:

```bash
node run.js --url=http://www.parliament.bg/bg/plenaryst --date=1374418193
```

Чрез нея е планирано да може скрипта да се изпълнява всеки ден и да обработва само нови стенограми.

#### Списък от години, месеци или дати, които трябва отново да се обработят
Възможно е и да се подава списък на години, месеци и дати, които трябва отново да се обработят. Списъкът трябва да е под формата на json документ.

Подаването на този списък към скрипта става като се подаде съдържанието на json документа към него. Или иначе казано списъка се _"pipe"_-не:

```bash
cat listOfForcedTimeSpans.json | node run.js --url=http://www.parliament.bg/bg/plenaryst
```
като `listOfForcedTimeSpans.json` файлът може да изглежда така (за години):

```json
[2013,2014]
```

или така (за месеци):

```json
{
   "2013": [8,9]
}
```

или (за точни дати):

```json
{
  "2013": {
    "8": [14,24]
  }
}
```

### Оформяне на изведената информация за запис
Записа на информацията зависи от желаната база данни. За всяка различна DB, документите ще се трансформират за да паснат на нейната структура.

Примерен _"декоратор"_ за SQL база данни има в `decorator/sql.js`. Дадения декоратор-скрипт се ползва като се пренасочи извежданата информация от `run.js` към него. Или иначе казано _"pipe"_:

```bash
node run.js --url=http://www.parliament.bg/bg/plenaryst | node decorator/sql.js
```

което ще превърне описания горе JSON документ в:

```json
{"destination":"mp_presence","data":{"name":"Иван Иванов","registration":"absent","commenced_at":"21-05-2013 11:30"}}
{"destination":"mp_vote","data":{"name":"Иван Иванов","vote":"yes","topic":"Увеличение на бюджета","time":"21-05-2013 11:54"}}
{"destination":"mp_vote","data":{"name":"Иван Иванов","vote":"yes","topic":"Решение за избор на председател","time":"21-05-2013 09:21"}}
```

Което на свой ред са нови JSON документи, като всеки 1 документ съдържа:

 - 1 поредица от данни съответстващи на точно 1 ред в базата данни
 - име на таблицата, където ще бъде запазен реда

Това вече може да се подаде към трети скрипт, които ще извършва самото записване в базата данни.